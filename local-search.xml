<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ROS机器人建模</title>
    <link href="/2022/11/24/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E6%A8%A1/"/>
    <url>/2022/11/24/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS基础知识代码例程</title>
    <link href="/2022/11/14/ROS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%A3%E7%A0%81%E4%BE%8B%E7%A8%8B/"/>
    <url>/2022/11/14/ROS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%A3%E7%A0%81%E4%BE%8B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>包含ROS话题通信，服务通信，launch文件的代码例程</p><span id="more"></span><h1 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h1><p>以小乌龟spawn服务调用为例，服务spawn的info如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 复制">type:turtlesim/Spawn<br>args:x y theta name<br></code></pre></td></tr></table></figure><h3 id="客户端示例"><a href="#客户端示例" class="headerlink" title="客户端示例"></a>客户端示例</h3><p>代码实现的功能：在屏幕上显示三个小乌龟，可以通过launch文件改变小乌龟2和小乌龟3的初始位姿和名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs 复制">#include &quot;ros/ros.h&quot;<br>#include &quot;turtlesim/Spawn.h&quot;//调用了功能包turtlesim下定义的服务功能包<br><br>int main(int argc, char *argv[])<br>&#123;<br>    ros::init(argc,argv,&quot;open_spawn&quot;);<br>    ros::NodeHandle nh;<br>    ros::ServiceClient client=nh.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;);<br>    //等待服务请求成功<br>    //方式一<br>    ros::service::waitForService(&quot;/spawn&quot;);<br>    //方式二<br>    //client.waitForExistence();<br>    turtlesim::Spawn spawn;<br>    spawn.request.name=argv[1];<br>    spawn.request.theta=std::atof(argv[4]);<br>    spawn.request.x=std::atof(argv[2]);<br>    spawn.request.y=std::atof(argv[3]);<br>    //发送请求,返回 bool 值，标记是否成功<br>    bool flag = client.call(spawn);<br>    if (flag)<br>    &#123;<br>        ROS_INFO(&quot;%s has created!&quot;,spawn.response.name.c_str());<br>    &#125;<br>    else<br>    &#123;<br>        ROS_ERROR(&quot;It is failed to create %s&quot;,spawn.response.name.c_str());<br>    &#125;<br>    ros::spin();<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务端示例"><a href="#服务端示例" class="headerlink" title="服务端示例"></a>服务端示例</h3><p>代码实现功能：节点node2接收node3的服务请求，并返回requst的和<br>代码中采用的自定义srv包multi_correspond_0430&#x2F;calculation，其内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 复制">Int32 a<br>Int32 b<br>---<br>Int32 result<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs 复制">#include &quot;ros/ros.h&quot;<br>#include &quot;multi_correspond_0430/calculation.h&quot;//自定义的服务包<br><br>bool callback(multi_correspond_0430::calculation::Request &amp;req,<br>                multi_correspond_0430::calculation::Response &amp;resp)<br>&#123;<br>    resp.result = req.a + req.b;<br>    ROS_INFO(&quot;I have received request from node3.My result is %d&quot;,resp.result);<br>    return true;<br>&#125;<br>int main(int argc, char *argv[])<br>&#123;<br>    ros::init(argc,argv,&quot;node_2_0430&quot;);<br>    ros::NodeHandle nh;<br>   <br>    ros::ServiceServer srv;<br>    //服务端不需要标明服务参数的类型<br>    srv = nh.advertiseService(&quot;calculation&quot;,callback);<br><br>    ros::spin();<br>    return 0;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="tf广播器"><a href="#tf广播器" class="headerlink" title="tf广播器"></a>tf广播器</h1><h1 id="综合实例–小乌龟跟随实验"><a href="#综合实例–小乌龟跟随实验" class="headerlink" title="综合实例–小乌龟跟随实验"></a>综合实例–小乌龟跟随实验</h1><p>实验现象：运行launch文件，屏幕产生三个小乌龟1，2，3，乌龟1会跟随乌龟2，乌龟2会跟随3，乌龟3画方形。<br>文件有三个cpp文件和一个launch文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs 复制">%% turtle_spawn_123.cpp<br>% 画出乌龟2和3<br>% 通过传参实现代码复用<br>#include &quot;ros/ros.h&quot;<br>#include &quot;turtlesim/Spawn.h&quot;<br><br>int main(int argc, char *argv[])<br>&#123;<br>    ros::init(argc,argv,&quot;open_spawn&quot;);<br>    ros::NodeHandle nh;<br>    ros::ServiceClient client=nh.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;);<br>    ros::service::waitForService(&quot;/spawn&quot;);<br>    turtlesim::Spawn spawn;<br>    spawn.request.name=argv[1];<br>    spawn.request.theta=std::atof(argv[4]);<br>    spawn.request.x=std::atof(argv[2]);<br>    spawn.request.y=std::atof(argv[3]);<br><br>    bool flag = client.call(spawn);<br>    if (flag)<br>    &#123;<br>        ROS_INFO(&quot;%s has created!&quot;,spawn.response.name.c_str());<br>    &#125;<br>    else<br>    &#123;<br>        ROS_ERROR(&quot;It is failed to create %s&quot;,spawn.response.name.c_str());<br>    &#125;<br>    ros::spin();<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs 复制">%% turtle_pub_pose.cpp<br>% 订阅/turtle/pose话题，得到三只乌龟的pose<br>% 将各个乌龟的pose发布到tf上<br>#include &quot;ros/ros.h&quot;<br>#include &quot;turtlesim/Pose.h&quot;<br>#include &quot;tf2_ros/transform_broadcaster.h&quot;<br>#include &quot;tf2/LinearMath/Quaternion.h&quot;<br>std::string turtle_name;<br><br>void doPose(turtlesim::Pose msg)<br>&#123;<br>    //创建 TF 广播器<br>    static tf2_ros::TransformBroadcaster broadcaster;<br>    //将 pose 信息转换成 TransFormStamped<br>    geometry_msgs::TransformStamped tfs;<br>    tfs.header.frame_id=&quot;world&quot;;<br>    tfs.header.seq=1;<br>    tfs.header.stamp=ros::Time::now();<br>    tfs.child_frame_id=turtle_name;<br>    tfs.transform.translation.x=msg.x;<br>    tfs.transform.translation.y=msg.y;  <br>    tfs.transform.translation.z=0;<br>    tf2::Quaternion qua;<br>    qua.setRPY(0,0,msg.theta);<br>    tfs.transform.rotation.x=qua.getX();<br>    tfs.transform.rotation.y=qua.getY();  <br>    tfs.transform.rotation.z=qua.getZ();  <br>    tfs.transform.rotation.w=qua.getW();  <br>    broadcaster.sendTransform(tfs);<br>&#125;<br>int main(int argc, char *argv[])<br>&#123;<br>    ros::init(argc,argv,&quot;sub_pose&quot;);<br>    if(argc!=2)<br>    &#123;<br>        ROS_ERROR(&quot;name is not inputed&quot;);<br>    &#125;<br>    ros::NodeHandle nh;<br>    turtle_name=argv[1];<br>    ros::Subscriber sub = nh.subscribe&lt;turtlesim::Pose&gt;(turtle_name+&quot;/pose&quot;,1000,doPose);<br>    ros::spin();<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs 复制">%% turtle_vel.cpp<br>% 接受tf坐标信息，计算跟随乌龟的速度v<br>% 将速度通过话题/turtle/cmd_vel发布<br>#include &quot;ros/ros.h&quot;<br>#include &quot;std_msgs/String.h&quot;<br>#include &quot;tf2_ros/transform_listener.h&quot;<br>#include &quot;geometry_msgs/TransformStamped.h&quot;<br>#include &quot;geometry_msgs/Twist.h&quot;<br><br>int main(int argc, char *argv[2])<br>&#123;<br>    ros::init(argc,argv,&quot;sub_TF&quot;);<br>    //创建 ros 句柄<br>    ros::NodeHandle nh;<br>    //创建 TF 订阅对象<br>    tf2_ros::Buffer buffer;<br>    tf2_ros::TransformListener listener(buffer);<br>    //处理订阅到的 TF<br>    std::string name1=argv[1];<br>    std::string name2=argv[2];<br>    ros::Publisher pub = nh.advertise&lt;geometry_msgs::Twist&gt;(&quot;/&quot;+name1+&quot;/cmd_vel&quot;,1000);<br>    ros::Rate rate(10);<br>    while (ros::ok())<br>    &#123;<br>        try<br>        &#123;<br>            //先获取 turtle1 相对 turtle2 的坐标信息<br>            geometry_msgs::TransformStamped tfs = buffer.lookupTransform(name1,name2,ros::Time(0));<br>            //根据坐标信息生成速度信息 -- geometry_msgs/Twist.h<br>            geometry_msgs::Twist twist;<br>            twist.linear.x = std::atof(argv[3]) * sqrt(pow(tfs.transform.translation.x,2) + pow(tfs.transform.translation.y,2));<br>            twist.angular.z = std::atof(argv[4]) * atan2(tfs.transform.translation.y,tfs.transform.translation.x);<br>            //发布速度信息 -- 需要提前创建 publish 对象<br>            pub.publish(twist);<br>        &#125;<br>        catch(const std::exception&amp; e)<br>        &#123;<br>            // std::cerr &lt;&lt; e.what() &lt;&lt; &#x27;\n&#x27;;<br>            ROS_INFO(&quot;错误提示:%s&quot;,e.what());<br>        &#125;<br>        rate.sleep();<br>        ros::spinOnce();<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs 复制">%% start.launch<br>&lt;launch&gt;<br>    &lt;node pkg=&quot;turtlesim&quot;<br>        name=&quot;turtlesim_node&quot;<br>        type=&quot;turtlesim_node&quot;/&gt;<br>    &lt;node pkg=&quot;turtle_track_0430&quot;<br>        name=&quot;turtle2&quot;<br>        type=&quot;turtle_spawn_123&quot;<br>        args=&quot;turtle2 4 8 0&quot;<br>        output=&quot;screen&quot;/&gt;<br>    &lt;node pkg=&quot;turtle_track_0430&quot;<br>        name=&quot;turtle3&quot;<br>        type=&quot;turtle_spawn_123&quot;<br>        args=&quot;turtle3 4 4 0&quot;<br>        output=&quot;screen&quot;/&gt;<br><br>    &lt;group ns=&quot;/turtle3&quot;&gt;<br>        &lt;remap from=&quot;/turtle3/turtle1/cmd_vel&quot; to=&quot;/turtle3/cmd_vel&quot;/&gt;<br>        &lt;node pkg=&quot;turtlesim&quot; type=&quot;draw_square&quot; name=&quot;draw_square&quot;&gt;<br>            &lt;remap from=&quot;/turtle3/turtle1/pose&quot; to=&quot;/turtle3/pose&quot;/&gt;<br>        &lt;/node&gt;<br>    &lt;/group&gt;<br><br>    &lt;node pkg=&quot;turtle_track_0430&quot;<br>        name=&quot;turtle_pub_pose1&quot;<br>        type=&quot;turtle_pub_pose&quot;<br>        args=&quot;turtle1&quot;<br>        output=&quot;screen&quot;/&gt;<br>    &lt;node pkg=&quot;turtle_track_0430&quot;<br>        name=&quot;turtle_pub_pose2&quot;<br>        type=&quot;turtle_pub_pose&quot;<br>        args=&quot;turtle2&quot;<br>        output=&quot;screen&quot;/&gt;<br>    &lt;node pkg=&quot;turtle_track_0430&quot;<br>        name=&quot;turtle_pub_pose3&quot;<br>        type=&quot;turtle_pub_pose&quot;<br>        args=&quot;turtle3&quot;<br>        output=&quot;screen&quot;/&gt;<br>    <br>    &lt;node pkg=&quot;turtle_track_0430&quot;<br>        name=&quot;turtle2_follow_3&quot;<br>        type=&quot;turtle_vel&quot;<br>        args=&quot;turtle2 turtle3 0.2 1&quot;/&gt;<br>    &lt;node pkg=&quot;turtle_track_0430&quot;<br>        name=&quot;turtle1_follow_2&quot;<br>        type=&quot;turtle_vel&quot;<br>        args=&quot;turtle1 turtle2 0.2 1&quot;/&gt;<br>    <br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>机器人操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群体优化算法</title>
    <link href="/2022/10/22/%E7%BE%A4%E4%BD%93%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <url>/2022/10/22/%E7%BE%A4%E4%BD%93%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>群体优化算法</p><span id="more"></span><h2 id="粒子群优化算法"><a href="#粒子群优化算法" class="headerlink" title="粒子群优化算法"></a>粒子群优化算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs 复制">%% I. 清空环境<br>clc<br>clear<br>close all<br>%% III. 参数初始化<br>c1 = 1.49445;<br>c2 = 1.49445;<br> <br>maxgen = 800;   % 进化次数  <br>sizepop = 10;   %种群规模<br> <br>Vmax = 1;   %速度的范围，超过则用边界值。<br>Vmin = -Vmax;  <br>popmax = 30;   %个体的变化范围<br>popmin = 0;<br><br>pop=zeros(sizepop,3);<br>process=cell(sizepop,2);<br>%% IV. 产生初始粒子和速度<br>for i = 1:sizepop<br>    % 随机产生一个种群<br>    pop(i,:) = [30 * rand(1),30 * rand(1),30 * rand(1)];    %初始种群，rand产生(0,1)，调整到(0,30)<br>    V(i,:) = [0.5 * rands(1),0.5 * rands(1),0.5 * rands(1)];  %初始化速度,速度有正负,rands产生(-1,1)<br>    % 计算适应度<br>    fitness(i) = fun(pop(i,:));   <br>end<br> <br>%% V. 个体极值和群体极值<br>[bestfitness,bestindex] = max(fitness);<br>zbest = pop(bestindex,:);   %全局最佳<br>gbest = pop;    %个体最佳<br>fitnessgbest = fitness;   %个体最佳适应度值<br>fitnesszbest = bestfitness;   %全局最佳适应度值<br> <br>%% VI. 迭代寻优<br>for i = 1:maxgen<br>    <br>    for j = 1:sizepop<br>        <br>        % 速度更新<br>        V(j,:) = V(j,:) + c1*rand*(gbest(j,:) - pop(j,:)) + c2*rand*(zbest - pop(j,:));<br>        V(j,V(j,:)&gt;Vmax) = Vmax;<br>        V(j,V(j,:)&lt;Vmin) = Vmin;<br>        <br>        % 种群更新<br>        pop(j,:) = pop(j,:) + V(j,:);<br>        pop(j,pop(j,:)&gt;popmax) = popmax;<br>        pop(j,pop(j,:)&lt;popmin) = popmin;<br>        <br>        % 适应度值更新<br>        fitness(j) = fun(pop(j,:));<br>        %记录个体每次迭代的位置,速度<br>        process&#123;j,1&#125;(i,:)=pop(j,:);<br>        process&#123;j,2&#125;(i,:)=V(j,:);<br>    end<br>    <br>    for j = 1:sizepop    <br>        % 个体最优更新<br>        if fitness(j) &gt; fitnessgbest(j)<br>            gbest(j,:) = pop(j,:);<br>            fitnessgbest(j) = fitness(j);<br>        end<br>        <br>        % 群体最优更新<br>        if fitness(j) &gt; fitnesszbest<br>            zbest = pop(j,:);<br>            fitnesszbest = fitness(j);<br>        end<br>    end <br>    yy(i) = fitnesszbest;          <br>end<br> <br>%% VII. 输出结果并绘图<br>disp([fitnesszbest zbest])<br>plot(zbest, fitnesszbest,&#x27;r*&#x27;)<br><br><br>figure<br>plot(yy)<br>title(&#x27;最优个体适应度&#x27;,&#x27;fontsize&#x27;,12);<br>xlabel(&#x27;进化代数&#x27;,&#x27;fontsize&#x27;,12);ylabel(&#x27;适应度&#x27;,&#x27;fontsize&#x27;,12);<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS中的launch文件</title>
    <link href="/2022/10/04/ROS%E4%B8%AD%E7%9A%84launch%E6%96%87%E4%BB%B6/"/>
    <url>/2022/10/04/ROS%E4%B8%AD%E7%9A%84launch%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>launch文件用于快速开启多个节点</p><span id="more"></span><h2 id="一、launch文件的编写"><a href="#一、launch文件的编写" class="headerlink" title="一、launch文件的编写"></a>一、launch文件的编写</h2><p>先略过</p><h2 id="二、XML文件常见标签介绍"><a href="#二、XML文件常见标签介绍" class="headerlink" title="二、XML文件常见标签介绍"></a>二、XML文件常见标签介绍</h2><h3 id="标签：运行节点设置"><a href="#标签：运行节点设置" class="headerlink" title="标签：运行节点设置"></a><node>标签：运行节点设置</h3><div class="note note-secondary">            <p>可设置的属性<br>前三个属性是必备的</p><ol><li>pkg&#x3D;“mypackage” package of node</li><li>type&#x3D;“nodetype” there must be a corresponding executable with the same name</li><li>name&#x3D;“nodename”redefine node name .NOTE: name cannot contain a namespace.use the “ns” attribute instead.</li><li>ns&#x3D;”foo” start the node in the ‘foo’ namespace.</li><li>respawn&#x3D;”true”(default: false) restart node automatically if it quits</li><li>respawn_delay&#x3D;”30”(default: 0) if respawn if ture. wait respawn_delay seconds after the node failure is detected before attempting restart.</li></ol>          </div>]]></content>
    
    
    
    <tags>
      
      <tag>机器人操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS命令行</title>
    <link href="/2022/09/27/ROS%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <url>/2022/09/27/ROS%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>常用命令行代码</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ rosrun package_name executable_file_name<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>机器人操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32实现红外接收</title>
    <link href="/2022/09/21/STM32%E5%AE%9E%E7%8E%B0%E7%BA%A2%E5%A4%96%E6%8E%A5%E6%94%B6/"/>
    <url>/2022/09/21/STM32%E5%AE%9E%E7%8E%B0%E7%BA%A2%E5%A4%96%E6%8E%A5%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p>通过这个实验可以实现：利用红外遥控器发射信号，在单片机上可以显示相应的数值。</p><span id="more"></span><h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p>在APP文件夹下添加exti.c文件(外部中断相关函数)</p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2>]]></content>
    
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS工程文件详情解析</title>
    <link href="/2022/09/21/ROS%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E8%AF%A6%E6%83%85%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/21/ROS%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E8%AF%A6%E6%83%85%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>详细解释通过VScode软件建立的ROS工程文件下，常见文件的作用及其内容的理解.</p><span id="more"></span><h1 id="workspace-x2F-src"><a href="#workspace-x2F-src" class="headerlink" title="workspace&#x2F;src"></a>workspace&#x2F;src</h1><h2 id="x2F-package-x2F-CMakeLists-txt"><a href="#x2F-package-x2F-CMakeLists-txt" class="headerlink" title=".&#x2F;package&#x2F;CMakeLists.txt"></a>.&#x2F;package&#x2F;CMakeLists.txt</h2><p>CMakeLists.txt就是整个功能包编译的核心管理系统，每个功能包内都会有一个，它里面记录了编译生成的可执行文件的名称、文置和它依赖的.cpp或.py文件。<br>例如下面这行代码就代表，我的文件包生成一个名为talker_0430的可执行文件，它编译依赖是 src&#x2F;talker_0430</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">add_executable(talker_0430 src/talker_0430.cpp)<br></code></pre></td></tr></table></figure><h2 id="x2F-package-x2F-srv-x2F-service-srv"><a href="#x2F-package-x2F-srv-x2F-service-srv" class="headerlink" title=".&#x2F;package&#x2F;srv&#x2F;service.srv"></a>.&#x2F;package&#x2F;srv&#x2F;service.srv</h2><p>服务通信必要的包，建好之后需要在CMakeLists.txt和package.xml文件中配置，配置内容见CMakeLists.txt内说明。<br>当你不理解的时候可以尝试阅读里面的官方注释。</p><h2 id="x2F-package-x2F-msg-x2F-message-msg"><a href="#x2F-package-x2F-msg-x2F-message-msg" class="headerlink" title=".&#x2F;package&#x2F;msg&#x2F;message.msg"></a>.&#x2F;package&#x2F;msg&#x2F;message.msg</h2><p>自定义消息类型文件，这样就可以发布自定义类型的消息。</p><h2 id="x2F-package-x2F-launch-x2F-start-launch"><a href="#x2F-package-x2F-launch-x2F-start-launch" class="headerlink" title=".&#x2F;package&#x2F;launch&#x2F;start.launch"></a>.&#x2F;package&#x2F;launch&#x2F;start.launch</h2><p>运行launch文件可以同时开启和操作多个节点。launch文件不需要编译，保存后即可运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ roslaunch package_name start.launch<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>机器人操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS概念理解</title>
    <link href="/2022/09/20/ROS%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <url>/2022/09/20/ROS%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>ROS中常见概念的理解<br>一个.cpp文件中可以设置多个节点句柄，但它们的区别只在于命名空间不同，表示的都是同一个节点。</p><h2 id="window中的句柄"><a href="#window中的句柄" class="headerlink" title="window中的句柄"></a>window中的句柄</h2><p>句柄本质上就是一个指向结构体的指针。句柄的内存地址一定，它里面记载了对象在内存中的地址；而对象在内存中的地址不稳定，当发生变化时，相应的会改变句柄里的数，而不改变句柄的地址。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>从程序角度来说，节点就是一个可执行文件（通常为c++生成的可执行文件、Python脚本）被执行，加载到了内存之中。<br>从功能的角度来说，通常一个节点负责机器人的某个单独的功能。<br>节点之间通过话题topic、服务service、动作action或者参数parameter实现数据的收发。<br>节点名通过.cpp文件(也可是.py)中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">ros::init::(argc,argv,&quot;node_name&quot;)<br></code></pre></td></tr></table></figure><h2 id="官方功能包"><a href="#官方功能包" class="headerlink" title="官方功能包"></a>官方功能包</h2><p>std_msgs是最常见的一个，它里面包含了初学者所涉及到的所有数据类型。我们可以通过使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ rosmsg list<br></code></pre></td></tr></table></figure><p>来列出ros中所有的功能包<br>还能用命令行得到某个功能包的官方解释，例如下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ rosmsg show std_msgs/Int8<br></code></pre></td></tr></table></figure><h2 id="ros-spin-和ros-spinOnce"><a href="#ros-spin-和ros-spinOnce" class="headerlink" title="ros::spin()和ros::spinOnce()"></a>ros::spin()和ros::spinOnce()</h2><p>刚接触ROS时，常看到例程中写ros::spin和ros::spinOnce()，可它们究竟是什么意思，还需要进一步学习才能更好地理解。<br>可以将ros::spin()想象成一个异空间，当代码执行到这一步后，就会进入这个空间，而且出不来！！这也就是为什么spin()常写在函数最后面。<br>那进入这个空间是要干嘛？在ROS中有许多通信相关内容的需要处理，而我们并没有在主函数中给它写出来。这时候就需要进入到spin()中去处理这些内容。比如最基础的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">ros::subscribe(&quot;chatter&quot;,10,domsg)<br></code></pre></td></tr></table></figure><p>这其中chatter代表订阅话题名，10可以暂时理解为传输数据的速度，domsg是消息处理函数，是需要用户编写的。可以发现我们在写消息订阅者时，并没有在主函数中调用domsg函数，而只是在这里指明了消息处理的函数。这个函数其实就是在进入spin()后被调用执行的。<br>而spinOnce()与spin()的区别就在于前者只进入一次，之后就会跳出来，而后者会一直自旋，这也就意味着程序到这里就会结束。<br>在使用中spinOnce()常用于主循环中，而spin()用于主函数结尾。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器人操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cource</title>
    <link href="/2022/09/14/cource/"/>
    <url>/2022/09/14/cource/</url>
    
    <content type="html"><![CDATA[<p>课程表</p><span id="more"></span><table><thead><tr><th></th><th>星期一</th><th>星期二</th><th>星期三</th><th>星期四</th><th>星期五</th><th>星期六</th><th>星期天</th></tr></thead><tbody><tr><td>第一大节</td><td>人工智能原理与方法</td><td>机械设计基础</td><td>专业英语阅读</td><td>机器人操作系统</td><td>专业英语阅读</td><td></td><td></td></tr><tr><td>第二大节</td><td>SolidWorks</td><td>机器人操作系统</td><td>数字信号处理基础</td><td>机械设计基础</td><td>SolidWorks</td><td></td><td></td></tr><tr><td>第三大节</td><td>机器人学</td><td></td><td>机器人学</td><td>人工智能原理与方法</td><td>数字信号处理基础</td><td></td><td></td></tr><tr><td>第四大节</td><td>运动控制</td><td>形式与政策</td><td></td><td>运动控制</td><td></td><td></td><td></td></tr><tr><td>第五大节</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模拟退火算法</title>
    <link href="/2022/09/12/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/12/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟退火算法-SAA"><a href="#模拟退火算法-SAA" class="headerlink" title="模拟退火算法 SAA"></a>模拟退火算法 SAA</h1><span id="more"></span><h2 id="一、核心内容"><a href="#一、核心内容" class="headerlink" title="一、核心内容"></a>一、核心内容</h2><p>　　　　　　　新解x1，新的函数值y1<br>　　　　　　　当前解x0，当前函数值y0<br>　　　　　　　最优解bestx，最优函数值besty<br>一个算法的核心之处就在于以下两方面：</p><div class="note note-secondary">            <p>核心一　通过当前解x0产生新解x1的规则，比如本算法就是通过对当前解x0进行随机扰动的方式得到新解x1。<br>核心二　接受新解的规则，比如本算法就是采用更优解直接接受，更差解按规则接受。</p>          </div><p>这个规则也就决定了该算法的优劣程度，这条规则越完美，算法得到的解就越快越准确。模拟退火算法的两条核心和规定的温度T都有关系！<br>下面给出模拟退火算法的两条核心规则：</p><div class="note note-secondary">            <p>核心一　产生新解<br>核心二　接受新解的伪代码</p>          </div><p>注意：每一轮后还要更新温度T，T&#x3D;k*T（0&lt;k&lt;1）</p><h2 id="二、实战例程"><a href="#二、实战例程" class="headerlink" title="二、实战例程"></a>二、实战例程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs 复制">function [bestx,BEST_Y] = SAA()<br>%SAA 模拟退火算法寻找最优解<br>%   此处提供详细说明<br>dt = 0.5;<br>T_10_11 = 25;<br><br>x_min = [65,165,185,225,245];%解得上界和下界<br>x_max = [100,185,205,245,265];<br><br>L = 200;%每个温度下的迭代次数<br>k = 0.98;%温度衰减系数<br>T_m = 100;%初始温度<br>p = 300;<br>BEST_Y = zeros(1,p);<br>%% 随机生成全局最优解<br>f = 0;<br>while(f == 0)<br>    x0 = zeros(1,5);<br>    for i = 1:5<br>        x0(i) = x_min(i) +(x_max(i) - x_min(i))*rand(1);<br>    end<br>    temp = temperature_graph( x0(1)/60,x0(2) , x0(3),x0(4), x0(5), T_10_11,dt);%环境温度<br>    Temp_result = T(54.025,44.72,0.0047,temp,x0(1)/60,dt);<br>    if(boundary_f(Temp_result,dt) == 1)%满足制程要求<br>        f = 1;<br>    end<br>    y0 = extent(x0(1),x0(2) , x0(3),x0(4), x0(5), T_10_11,dt);%当前解得函数值<br><br>end<br>%% <br>bestx = x0;<br>besty = y0;<br>for i = 1:p<br>    for j = 1:L<br>        %根据新解产生规则产生新解<br>        f =0;<br>        while f==0<br>            m = randn(1,5);<br>            z = m/sqrt(sum(m.^2));<br>            x_new = x0 + z*T_m;<br>            %如果新解超出上下界,则进行校正<br>            for n = 1:5<br>                if(x_new(n)&lt;x_min(n))<br>                    r = rand(1);<br>                    x_new(n) = r*x_min(n) + (1-r)*x0(n);<br>                elseif(x_new(n)&gt;x_max(n))<br>                    r = rand(1);<br>                    x_new(n) = r*x_max(n) + (1-r)*x0(n);<br>                end<br>            end<br>            temp = temperature_graph( x_new(1)/60,x_new(2) , x_new(3),x_new(4), x_new(5), T_10_11,dt);%环境温度<br>            Temp_result = T(54.025,44.72,0.0047,temp,x_new(1)/60,dt);<br>            if(boundary_f(Temp_result,dt) == 1)%满足制程要求<br>                f = 1;<br>            end<br>        end<br>        x1 = x_new;%赋值新解<br>        y1 = extent(x1(1),x1(2) , x1(3),x1(4), x1(5), T_10_11,dt);%新解得函数值<br>        %如果新解的值小于当前解,则将新解值赋予当前接<br>        %否则根据metropolis准则计算是否接受新解<br>        if(y1 &lt; y0)<br>            x0 = x1; <br>            y0 = y1;<br>        else<br>            if rand(1)&lt;exp(-(y0 - y1)/T_m)<br>                x0 = x1;<br>                y0 = y1;<br>            end<br><br>        end<br>        %判断是否要更新找到的全局最优解<br>        if(y0 &lt; besty)<br>            bestx = x0;<br>            besty = y0;<br>        end<br><br>    end<br>    BEST_Y(i) = besty;%保存本轮找到的最小面积<br>    T_m = k*T_m;%温度下降<br>end<br>end<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新建第一个ROS工程文件</title>
    <link href="/2022/09/12/%E6%96%B0%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAROS%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6/"/>
    <url>/2022/09/12/%E6%96%B0%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAROS%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>从最基础的层面来学习ROS工程文件的内容，下面将采用两种方式建立一个ROS工程文件。一种是手动法，一种是利用VScode的方法。手动法能让你更容易理解这个文件构建的含义，从更低层的角度理解ROS工程文件。</p><span id="more"></span><h2 id="一、了解ROS工程文件的目录"><a href="#一、了解ROS工程文件的目录" class="headerlink" title="一、了解ROS工程文件的目录"></a>一、了解ROS工程文件的目录</h2><p>ROS工程文件的标准目录及各部分的作用</p><div class="note note-secondary">            <p>catkin_workspace　　&#x2F;&#x2F;工程文件的根文件夹，可以随意命名<br>　|<br>　|–devel　　&#x2F;&#x2F;开发空间<br>　|<br>　|–build　　&#x2F;&#x2F;编译空间<br>　|<br>　|__src　　　&#x2F;&#x2F;源码空间，用户主要编辑的部分<br>　　|<br>　　|–package1<br>　　|　　　　　　<br>　　|__package2<br>　　　　　|<br>　　　　　|–CMakeLists.txt<br>　　　　　|–package.xml<br>　　　　　|–scrpits<br>　　　　　|–msg<br>　　　　　|–srv<br>　　　　　|–include<br>　　　　　|–src<br>　　　　　|__launch</p>          </div><h2 id="二、手动法"><a href="#二、手动法" class="headerlink" title="二、手动法"></a>二、手动法</h2><h3 id="配置工作空间"><a href="#配置工作空间" class="headerlink" title="配置工作空间"></a>配置工作空间</h3><p>1.创建工作空间(也可以右键建文件夹)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ mkdir -p ~/catkin_ws/src<br>$ cd ~/catkin_ws/src<br>$ catkin_init_workspace<br></code></pre></td></tr></table></figure><p>2.编译工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ cd ~/catkin_ws/<br>$ catkin_make<br></code></pre></td></tr></table></figure><p>3.设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ source devel/setup.bash<br></code></pre></td></tr></table></figure><p>4.检查环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ echo $ROS_PACKAGE_PATH<br></code></pre></td></tr></table></figure><h3 id="配置功能包"><a href="#配置功能包" class="headerlink" title="配置功能包"></a>配置功能包</h3><p>1.创建功能包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ cd ~/catkin_ws/src<br>$ catkin_create_pkg myfirst_pkg std_msgs roscpp<br></code></pre></td></tr></table></figure><p>2.编译功能包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ cd ~/catkin_ws<br>$ catkin_make<br>$ source devel/setup.bash<br></code></pre></td></tr></table></figure><h3 id="建立可执行文件"><a href="#建立可执行文件" class="headerlink" title="建立可执行文件"></a>建立可执行文件</h3><p>在package&#x2F;src下建.cpp文件，在package&#x2F;include&#x2F;package&#x2F;下建.h文件。</p><h3 id="配置CMakeLists-txt文件"><a href="#配置CMakeLists-txt文件" class="headerlink" title="配置CMakeLists.txt文件"></a>配置CMakeLists.txt文件</h3><p>配置的目的是规定编程时的可执行文件及其路径，以及可执行文件包含的头文件的路径。<br>打开该文本文件，主要有两个部分要修改，都在build部分<br>1.指定编译的.cpp文件<br>找到 Delcare a c++executable部分<br>在下面添加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">add_executable(包名 src/*.cpp src/*.cpp)<br></code></pre></td></tr></table></figure><p>2.指定头文件的所在地<br>找到 specify additional locations of header files<br>在下面修改代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 复制">include_directories(<br>include<br>include/包名<br>$&#123;catkin_INCLUDE_DIRS&#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ catkin_make<br>$ source devel/setup.bash<br></code></pre></td></tr></table></figure><p>运行—-rosrun 功能包包名 包下的主函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制">$ rosrun myfirst_pkg main<br></code></pre></td></tr></table></figure><h2 id="三、利用VScode法建立工程文件"><a href="#三、利用VScode法建立工程文件" class="headerlink" title="三、利用VScode法建立工程文件"></a>三、利用VScode法建立工程文件</h2>]]></content>
    
    
    
    <tags>
      
      <tag>机器人操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS系统的安装</title>
    <link href="/2022/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS系统"><a href="#ROS系统" class="headerlink" title="ROS系统"></a>ROS系统</h1><p>ROS全称robot operating system，是一种用于编写机器人软件的灵活框架，是工具、库和协议的集合。</p><span id="more"></span><p><a href="https://wiki.ros.org/">ROS官方网站</a></p><h2 id="安装ROS系统"><a href="#安装ROS系统" class="headerlink" title="安装ROS系统"></a>安装ROS系统</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>获取虚拟机VMware Player安装包<br><a href="https://customerconnect.vmware.com/en/downloads/details?downloadGroup=WKST-PLAYER-1624&productId=1039&rPId=91446#product_downloads">VMware Player官网</a><br>根据自己的电脑系统，选择对应的安装包。</p></li><li><p>获取Ubuntu系统安装包<br><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">清华大学开源软件镜像站</a><br>Ubuntu官网下载会特别慢，所以建议用国内的镜像网站。<br>进入上面的网站后，选择你想安装的Ubuntu版本。我下载的是20.04版本，Ubuntu版本和ROS的版本是对应的，所以我下载的ROS版本是Noetic。对应关系如下，可以根据你想要的ROS版本下载相应版本的Ubuntu。</p></li></ol><table><thead><tr><th>Ubuntu版本</th><th>ROS名称</th><th>常用简称</th></tr></thead><tbody><tr><td>20.04</td><td>ROS Noetic Ninjemys</td><td>Noetic</td></tr><tr><td>18.04</td><td>ROS Melodic Morenia</td><td>Melodic</td></tr><tr><td>16.04</td><td>ROS Kinetic Kame</td><td>Kinetic</td></tr></tbody></table><h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><ol><li>安装虚拟机VMware Player<br>根据它的安装向导一步步安装就行，不过注意一下安装路径，建议改到一个c盘以外并且有60个G以上剩余空间的磁盘。（磁盘剩余，30G不能再少了，不然，在后面的学习过程中很难再在虚拟机中安装或运行一些需要的程序）</li><li>安装Ubuntu系统<br><a href="https://blog.csdn.net/weixin_44410537/article/details/100938963">Ubuntu 20.04 虚拟机安装教程</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>机器人操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法总结</title>
    <link href="/2022/08/28/hello-world/"/>
    <url>/2022/08/28/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="一、如何写标签-note"><a href="#一、如何写标签-note" class="headerlink" title="一、如何写标签(note)"></a>一、如何写标签(note)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 复制">&#123;% note success %&#125;<br>这是一个测试，测试标签功能。<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>这是一个测试，测试标签功能。</p>          </div><p>还可以有其他的颜色</p><div class="note note-primary">            <p>primary</p>          </div><div class="note note-secondary">            <p>secondary</p>          </div><div class="note note-danger">            <p>danger</p>          </div><div class="note note-warning">            <p>warning</p>          </div><div class="note note-info">            <p>info</p>          </div><div class="note note-light">            <p>light</p>          </div><h2 id="二、如何控制文章的缩进"><a href="#二、如何控制文章的缩进" class="headerlink" title="二、如何控制文章的缩进"></a>二、如何控制文章的缩进</h2><p>将输入法切换到全角输入法，此时空格键就可以控制缩进</p><h2 id="三、如何绘制表格"><a href="#三、如何绘制表格" class="headerlink" title="三、如何绘制表格"></a>三、如何绘制表格</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 复制">|表头一|表头二|表头三|<br>|-------|------|-------|<br>|（1，1）|（1，2）|（1，3）|<br>|（2，1）|（2，2）|（2，3）|<br>|（3，1）|（3，2）|（3，3）|<br></code></pre></td></tr></table></figure><table><thead><tr><th>表头一</th><th>表头二</th><th>表头三</th></tr></thead><tbody><tr><td>（1，1）</td><td>（1，2）</td><td>（1，3）</td></tr><tr><td>（2，1）</td><td>（2，2）</td><td>（2，3）</td></tr><tr><td>（3，1）</td><td>（3，2）</td><td>（3，3）</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
